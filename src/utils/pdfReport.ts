import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { formatCAD, formatPct } from './formatters';
import type { Scenario } from '../types/scenario';
import type { ComputedScenario, ComputedYear } from '../types/computed';

export interface PDFSections {
  overview: boolean;
  taxDetail: boolean;
  accounts: boolean;
  expenses: boolean;
  timeline: boolean;
  scheduling: boolean;
  analysis: boolean;
  warnings: boolean;
  settings: boolean;
}

interface ReportInput {
  scenario: Scenario;
  computed: ComputedScenario;
  sections?: PDFSections;
}

const ACCENT: [number, number, number] = [16, 185, 129];
const HEADER_BG: [number, number, number] = ACCENT;
const TEXT_DARK: [number, number, number] = [15, 23, 42];
const TEXT_MED: [number, number, number] = [51, 65, 85];
const TEXT_LIGHT: [number, number, number] = [100, 116, 139];
const WHITE: [number, number, number] = [255, 255, 255];

// ── Helpers ────────────────────────────────────────────────────────

function getY(doc: any): number {
  return doc.lastAutoTable?.finalY ?? 14;
}

function sectionTitle(doc: jsPDF, title: string, margin: number): number {
  const y = 14;
  const pageWidth = doc.internal.pageSize.getWidth();
  doc.setFillColor(...ACCENT);
  doc.rect(margin, y - 5, pageWidth - margin * 2, 8, 'F');
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(...WHITE);
  doc.text(title, margin + 3, y);
  return y + 8;
}

function subTitle(doc: jsPDF, title: string, margin: number, y: number): number {
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(...TEXT_DARK);
  doc.text(title, margin, y);
  return y + 5;
}

function addFooter(doc: jsPDF, margin: number) {
  const pageCount = (doc as any).internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    doc.setFontSize(7);
    doc.setTextColor(...TEXT_LIGHT);
    doc.text('Generated by CDN Tax & Investment Model', margin, pageHeight - 8);
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 8, { align: 'right' });
  }
}

function addHeader(doc: jsPDF, scenario: Scenario, margin: number): number {
  const pageWidth = doc.internal.pageSize.getWidth();
  doc.setFillColor(...ACCENT);
  doc.rect(0, 0, pageWidth, 18, 'F');
  doc.setFontSize(14);
  doc.setTextColor(...WHITE);
  doc.setFont('helvetica', 'bold');
  doc.text('Financial Plan Summary', margin, 12);

  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(...TEXT_DARK);
  let y = 26;
  doc.text(scenario.name, margin, y);
  doc.setTextColor(...TEXT_LIGHT);
  doc.text(new Date().toLocaleDateString('en-CA'), pageWidth - margin, y, { align: 'right' });
  return y + 6;
}

function fmtBracket(min: number, max: number | null): string {
  if (max === null) return `${formatCAD(min)}+`;
  return `${formatCAD(min)} – ${formatCAD(max)}`;
}

// ── Section: Overview ──────────────────────────────────────────────

function addOverviewSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const a = scenario.assumptions;
  const numYears = scenario.years.length;
  const startYear = scenario.years[0]?.year ?? new Date().getFullYear();

  // Assumptions box
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'plain',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_MED },
    headStyles: { fillColor: [241, 245, 249], textColor: TEXT_DARK, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Assumption', 'Value', 'Assumption', 'Value']],
    body: [
      ['Province', a.province, 'Start Year', String(startYear)],
      ['Years', String(numYears), 'Inflation', formatPct(a.inflationRate)],
      ['Equity Return', formatPct(a.assetReturns.equity), 'Fixed Return', formatPct(a.assetReturns.fixedIncome)],
      ['Cash Return', formatPct(a.assetReturns.cash), 'Savings Return', formatPct(a.assetReturns.savings)],
    ],
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: contentWidth * 0.2 },
      1: { cellWidth: contentWidth * 0.3 },
      2: { fontStyle: 'bold', cellWidth: contentWidth * 0.2 },
      3: { cellWidth: contentWidth * 0.3 },
    },
  });
  y = getY(doc) + 6;

  // Lifetime KPIs
  const analytics = computed.analytics;
  const lastYear = computed.years[computed.years.length - 1];
  const finalNW = lastYear?.accounts.netWorth ?? 0;

  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 8, cellPadding: 2.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 8 },
    head: [['Lifetime Metric', 'Value']],
    body: [
      ['Lifetime Gross Income', formatCAD(analytics.lifetimeGrossIncome)],
      ['Lifetime Total Tax', formatCAD(analytics.lifetimeTotalTax)],
      ['Lifetime CPP + EI', formatCAD(analytics.lifetimeCPPEI)],
      ['Lifetime After-Tax Income', formatCAD(analytics.lifetimeAfterTaxIncome)],
      ['Lifetime Avg Tax Rate', formatPct(analytics.lifetimeAvgTaxRate)],
      ['Lifetime Avg All-In Rate', formatPct(analytics.lifetimeAvgAllInRate)],
      ['Lifetime Cash Flow', formatCAD(analytics.lifetimeCashFlow)],
      ['Final Net Worth', formatCAD(finalNW)],
    ],
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: contentWidth * 0.5 },
      1: { halign: 'right' },
    },
  });
  y = getY(doc) + 6;

  // Annual Summary
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7.5, cellPadding: 1.8, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Year', 'Gross Income', 'Total Tax', 'After-Tax', 'Net Worth', 'Marg. Rate']],
    body: computed.years.map(yr => [
      String(yr.year),
      formatCAD(yr.waterfall.grossIncome),
      formatCAD(yr.tax.totalIncomeTax + yr.cpp.totalCPPPaid + yr.ei.totalEI),
      formatCAD(yr.waterfall.afterTaxIncome),
      formatCAD(yr.accounts.netWorth),
      formatPct(yr.tax.marginalCombinedRate),
    ]),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 16 },
      1: { halign: 'right' },
      2: { halign: 'right' },
      3: { halign: 'right' },
      4: { halign: 'right' },
      5: { halign: 'right' },
    },
  });
}

// ── Section: Tax Detail ────────────────────────────────────────────

function addTaxDetailSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const lastIdx = computed.years.length - 1;
  const yr = computed.years[lastIdx];
  const yd = scenario.years[lastIdx];
  if (!yr || !yd) return;

  // Income composition
  y = subTitle(doc, `Income Composition — Year ${yr.year}`, margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.8, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Source', 'Amount']],
    body: [
      ['Employment Income', formatCAD(yd.employmentIncome)],
      ['Self-Employment Income', formatCAD(yd.selfEmploymentIncome)],
      ['Eligible Dividends (actual)', formatCAD(yd.eligibleDividends)],
      ['Non-Eligible Dividends (actual)', formatCAD(yd.nonEligibleDividends)],
      ['Interest Income', formatCAD(yd.interestIncome)],
      ['Capital Gains Realized', formatCAD(yd.capitalGainsRealized)],
      ['Rental Net Income', formatCAD(yd.rentalGrossIncome - yd.rentalExpenses)],
      ['Pension Income', formatCAD(yd.pensionIncome)],
      ['CPP Income', formatCAD(yr.retirement.cppIncome)],
      ['OAS Income', formatCAD(yr.retirement.oasIncome)],
      ['RRSP Withdrawal', formatCAD(yd.rrspWithdrawal)],
      ['Other Taxable Income', formatCAD(yd.otherTaxableIncome)],
      ['Total Gross Income', formatCAD(yr.waterfall.grossIncome)],
    ],
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 },
      1: { halign: 'right' },
    },
  });
  y = getY(doc) + 5;

  // Deductions
  y = subTitle(doc, 'Deductions', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.8, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Deduction', 'Amount']],
    body: [
      ['RRSP Deduction', formatCAD(yd.rrspDeductionClaimed)],
      ['FHSA Deduction', formatCAD(yd.fhsaDeductionClaimed)],
      ['CPP SE Employer Half', formatCAD(yr.cpp.cppSEEmployerHalfDed)],
      ['Capital Loss Applied', formatCAD(yd.capitalLossApplied)],
      ['Other Deductions', formatCAD(yd.otherDeductions)],
      ['Net Taxable Income', formatCAD(yr.tax.netTaxableIncome)],
    ],
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 },
      1: { halign: 'right' },
    },
  });
  y = getY(doc) + 5;

  // Federal brackets
  y = subTitle(doc, 'Federal Tax Brackets', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Bracket', 'Rate', 'Income in Bracket', 'Tax']],
    body: yr.taxDetail.federalBracketDetail.map(b => [
      fmtBracket(b.min, b.max),
      formatPct(b.rate),
      formatCAD(b.incomeInBracket),
      formatCAD(b.taxInBracket),
    ]),
    columnStyles: { 1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' } },
  });
  y = getY(doc) + 2;

  // Federal credits & payable summary
  const td = yr.taxDetail;
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'plain',
    styles: { fontSize: 7, cellPadding: 1.2, textColor: TEXT_MED },
    body: [
      ['Federal Tax Before Credits', formatCAD(yr.tax.federalTaxBeforeCredits)],
      ['Federal Credits', formatCAD(yr.tax.federalCredits)],
      ['Federal Tax Payable', formatCAD(yr.tax.federalTaxPayable)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 5;

  // Provincial brackets
  y = subTitle(doc, 'Provincial Tax Brackets', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Bracket', 'Rate', 'Income in Bracket', 'Tax']],
    body: yr.taxDetail.provincialBracketDetail.map(b => [
      fmtBracket(b.min, b.max),
      formatPct(b.rate),
      formatCAD(b.incomeInBracket),
      formatCAD(b.taxInBracket),
    ]),
    columnStyles: { 1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' } },
  });
  y = getY(doc) + 2;

  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'plain',
    styles: { fontSize: 7, cellPadding: 1.2, textColor: TEXT_MED },
    body: [
      ['Provincial Tax Before Credits', formatCAD(yr.tax.provincialTaxBeforeCredits)],
      ['Provincial Credits', formatCAD(yr.tax.provincialCredits)],
      ['Ontario Surtax', formatCAD(yr.tax.ontarioSurtax)],
      ['ON Health Premium', formatCAD(yr.tax.ontarioHealthPremium)],
      ['Provincial Tax Payable', formatCAD(yr.tax.provincialTaxPayable)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 5;

  // CPP/EI summary
  y = subTitle(doc, 'CPP & EI', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Item', 'Amount']],
    body: [
      ['CPP1 Employee', formatCAD(yr.cpp.cppEmployee)],
      ['CPP2 Employee', formatCAD(yr.cpp.cpp2Employee)],
      ['CPP Self-Employed', formatCAD(yr.cpp.cppSE)],
      ['CPP2 Self-Employed', formatCAD(yr.cpp.cpp2SE)],
      ['Total CPP', formatCAD(yr.cpp.totalCPPPaid)],
      ['EI Employment', formatCAD(yr.ei.eiEmployment)],
      ['EI Self-Employed', formatCAD(yr.ei.eiSE)],
      ['Total EI', formatCAD(yr.ei.totalEI)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 5;

  // Tax rates
  y = subTitle(doc, 'Effective Tax Rates', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['Federal Marginal Rate', formatPct(yr.tax.marginalFederalRate)],
      ['Provincial Marginal Rate', formatPct(yr.tax.marginalProvincialRate)],
      ['Combined Marginal Rate', formatPct(yr.tax.marginalCombinedRate)],
      ['Avg Income Tax Rate', formatPct(yr.tax.avgIncomeTaxRate)],
      ['Avg All-In Rate', formatPct(yr.tax.avgAllInRate)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 6;

  // All-years tax comparison (new page if needed)
  doc.addPage();
  y = subTitle(doc, 'All-Year Tax Comparison', margin, 14);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7.5, cellPadding: 1.8, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Year', 'Fed Tax', 'Prov Tax', 'CPP', 'EI', 'Total', 'Marg Rate', 'Avg Rate']],
    body: computed.years.map(cy => {
      const total = cy.tax.totalIncomeTax + cy.cpp.totalCPPPaid + cy.ei.totalEI;
      return [
        String(cy.year),
        formatCAD(cy.tax.federalTaxPayable),
        formatCAD(cy.tax.provincialTaxPayable),
        formatCAD(cy.cpp.totalCPPPaid),
        formatCAD(cy.ei.totalEI),
        formatCAD(total),
        formatPct(cy.tax.marginalCombinedRate),
        formatPct(cy.tax.avgAllInRate),
      ];
    }),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 14 },
      1: { halign: 'right' }, 2: { halign: 'right' },
      3: { halign: 'right' }, 4: { halign: 'right' },
      5: { halign: 'right', fontStyle: 'bold' },
      6: { halign: 'right' }, 7: { halign: 'right' },
    },
  });
}

// ── Section: Accounts ──────────────────────────────────────────────

function addAccountsSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const lastIdx = computed.years.length - 1;
  const yr = computed.years[lastIdx];
  const yd = scenario.years[lastIdx];
  if (!yr || !yd) return;

  // Account balance flow for last year
  y = subTitle(doc, `Account Flow — Year ${yr.year}`, margin, y);
  const prevYr = lastIdx > 0 ? computed.years[lastIdx - 1] : null;
  const openRRSP = prevYr ? prevYr.accounts.rrspEOY : (scenario.openingBalances.rrsp ?? 0);
  const openTFSA = prevYr ? prevYr.accounts.tfsaEOY : (scenario.openingBalances.tfsa ?? 0);
  const openFHSA = prevYr ? prevYr.accounts.fhsaEOY : (scenario.openingBalances.fhsa ?? 0);
  const openNR = prevYr ? prevYr.accounts.nonRegEOY : (scenario.openingBalances.nonReg ?? 0);
  const openSav = prevYr ? prevYr.accounts.savingsEOY : (scenario.openingBalances.savings ?? 0);
  const openLIRA = prevYr ? prevYr.accounts.liraEOY : (scenario.openingBalances.lira ?? 0);
  const openRESP = prevYr ? prevYr.accounts.respEOY : (scenario.openingBalances.resp ?? 0);

  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Account', 'Opening', '+Contrib', '-Withdraw', 'Return', 'EOY']],
    body: [
      ['RRSP', formatCAD(openRRSP), formatCAD(yd.rrspContribution), formatCAD(yd.rrspWithdrawal), formatCAD(yr.accounts.rrspReturn), formatCAD(yr.accounts.rrspEOY)],
      ['TFSA', formatCAD(openTFSA), formatCAD(yd.tfsaContribution), formatCAD(yd.tfsaWithdrawal), formatCAD(yr.accounts.tfsaReturn), formatCAD(yr.accounts.tfsaEOY)],
      ['FHSA', formatCAD(openFHSA), formatCAD(yd.fhsaContribution), formatCAD(yd.fhsaWithdrawal), formatCAD(yr.accounts.fhsaReturn), formatCAD(yr.accounts.fhsaEOY)],
      ['Non-Reg', formatCAD(openNR), formatCAD(yd.nonRegContribution), formatCAD(yd.nonRegWithdrawal), formatCAD(yr.accounts.nonRegReturn), formatCAD(yr.accounts.nonRegEOY)],
      ['Savings', formatCAD(openSav), formatCAD(yd.savingsDeposit), formatCAD(yd.savingsWithdrawal), formatCAD(yr.accounts.savingsReturn), formatCAD(yr.accounts.savingsEOY)],
      ['LIRA/LIF', formatCAD(openLIRA), '—', formatCAD(yd.lifWithdrawal), formatCAD(yr.accounts.liraReturn), formatCAD(yr.accounts.liraEOY)],
      ['RESP', formatCAD(openRESP), formatCAD(yd.respContribution), formatCAD(yd.respWithdrawal), formatCAD(yr.accounts.respReturn), formatCAD(yr.accounts.respEOY)],
    ],
    columnStyles: {
      0: { fontStyle: 'bold' },
      1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' }, 4: { halign: 'right' }, 5: { halign: 'right' },
    },
  });
  y = getY(doc) + 5;

  // Room tracking
  y = subTitle(doc, 'Contribution Room & Carry-Forwards', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['RRSP Unused Room', formatCAD(yr.rrspUnusedRoom)],
      ['TFSA Unused Room', formatCAD(yr.tfsaUnusedRoom)],
      ['FHSA Lifetime Contributions', formatCAD(yr.fhsaContribLifetime)],
      ['FHSA Unused Room', formatCAD(yr.fhsaUnusedRoom)],
      ['Capital Loss CF', formatCAD(yr.capitalLossCF)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 5;

  // Liabilities if present
  if (yr.liabilities && yr.liabilities.length > 0) {
    y = subTitle(doc, 'Liabilities', margin, y);
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'striped',
      styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
      headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
      head: [['Liability', 'Opening', 'Interest', 'Principal', 'Payment', 'Closing']],
      body: yr.liabilities.map(l => [
        l.label,
        formatCAD(l.openingBalance),
        formatCAD(l.interestPaid),
        formatCAD(l.principalPaid),
        formatCAD(l.totalPayment),
        formatCAD(l.closingBalance),
      ]),
      columnStyles: {
        0: { fontStyle: 'bold' },
        1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' }, 4: { halign: 'right' }, 5: { halign: 'right' },
      },
    });
    y = getY(doc) + 5;
  }

  // All-years account balances
  doc.addPage();
  y = subTitle(doc, 'All-Year Account Balances', margin, 14);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7.5, cellPadding: 1.8, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Year', 'RRSP', 'TFSA', 'FHSA', 'Non-Reg', 'Savings', 'LIRA/LIF', 'RESP', 'Net Worth']],
    body: computed.years.map(cy => [
      String(cy.year),
      formatCAD(cy.accounts.rrspEOY),
      formatCAD(cy.accounts.tfsaEOY),
      formatCAD(cy.accounts.fhsaEOY),
      formatCAD(cy.accounts.nonRegEOY),
      formatCAD(cy.accounts.savingsEOY),
      formatCAD(cy.accounts.liraEOY),
      formatCAD(cy.accounts.respEOY),
      formatCAD(cy.accounts.netWorth),
    ]),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 14 },
      1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' },
      4: { halign: 'right' }, 5: { halign: 'right' }, 6: { halign: 'right' },
      7: { halign: 'right' }, 8: { halign: 'right', fontStyle: 'bold' },
    },
  });
}

// ── Section: Expenses ──────────────────────────────────────────────

function addExpensesSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const effYears = computed.effectiveYears;
  const cyears = computed.years;

  // Expense categories
  const categories = [
    { key: 'housingExpense', label: 'Housing' },
    { key: 'groceriesExpense', label: 'Groceries' },
    { key: 'transportationExpense', label: 'Transportation' },
    { key: 'utilitiesExpense', label: 'Utilities' },
    { key: 'insuranceExpense', label: 'Insurance' },
    { key: 'entertainmentExpense', label: 'Entertainment' },
    { key: 'personalExpense', label: 'Personal' },
    { key: 'otherLivingExpense', label: 'Other' },
  ];

  // Summary table: all years
  y = subTitle(doc, 'Living Expenses by Year', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Year', ...categories.map(c => c.label), 'Total', 'After-Tax', 'After Expenses']],
    body: cyears.map((cy, i) => {
      const yd = effYears[i] ?? scenario.years[i];
      if (!yd) return [String(cy.year)];
      const vals = categories.map(c => formatCAD((yd as any)[c.key] ?? 0));
      return [
        String(cy.year),
        ...vals,
        formatCAD(cy.waterfall.totalLivingExpenses),
        formatCAD(cy.waterfall.afterTaxIncome),
        formatCAD(cy.waterfall.afterExpenses),
      ];
    }),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 14 },
      ...Object.fromEntries(categories.map((_, i) => [i + 1, { halign: 'right' as const }])),
      [categories.length + 1]: { halign: 'right' as const, fontStyle: 'bold' as const },
      [categories.length + 2]: { halign: 'right' as const },
      [categories.length + 3]: { halign: 'right' as const },
    },
  });
  y = getY(doc) + 6;

  // Budget summary for last year
  const lastIdx = cyears.length - 1;
  const lastYd = effYears[lastIdx] ?? scenario.years[lastIdx];
  const lastCy = cyears[lastIdx];
  if (lastYd && lastCy && lastCy.waterfall.totalLivingExpenses > 0) {
    y = subTitle(doc, `Expense Breakdown — Year ${lastCy.year}`, margin, y);
    const total = lastCy.waterfall.totalLivingExpenses;
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'grid',
      styles: { fontSize: 8, cellPadding: 2, textColor: TEXT_DARK },
      headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 8 },
      head: [['Category', 'Amount', '% of Total']],
      body: categories
        .map(c => {
          const amt = (lastYd as any)[c.key] ?? 0;
          return [c.label, formatCAD(amt), amt > 0 ? formatPct(amt / total) : '—'];
        })
        .concat([['Total', formatCAD(total), '100%']]),
      columnStyles: {
        0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 },
        1: { halign: 'right' as const },
        2: { halign: 'right' as const },
      },
    });
  }
}

// ── Section: Warnings ─────────────────────────────────────────────

function addWarningsSection(doc: jsPDF, _scenario: Scenario, computed: ComputedScenario, margin: number, _contentWidth: number, startY: number) {
  let y = startY;

  const allWarnings: { year: number; severity: string; field: string; message: string }[] = [];
  for (const cy of computed.years) {
    for (const w of cy.warnings) {
      allWarnings.push({ year: cy.year, severity: w.severity, field: w.field, message: w.message });
    }
  }

  if (allWarnings.length === 0) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...TEXT_MED);
    doc.text('No validation issues found. All checks passed.', margin, y);
    return;
  }

  const errors = allWarnings.filter(w => w.severity === 'error');
  const warnings = allWarnings.filter(w => w.severity === 'warning');

  // Summary
  y = subTitle(doc, `${errors.length} error${errors.length !== 1 ? 's' : ''}, ${warnings.length} warning${warnings.length !== 1 ? 's' : ''} across ${new Set(allWarnings.map(w => w.year)).size} years`, margin, y);

  // Deduplicate
  const seen = new Set<string>();
  const unique = allWarnings.filter(w => {
    const key = `${w.year}:${w.field}:${w.message}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  // Sort: errors first, then by year
  unique.sort((a, b) => {
    if (a.severity !== b.severity) return a.severity === 'error' ? -1 : 1;
    return a.year - b.year;
  });

  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7.5, cellPadding: 2, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['', 'Year', 'Field', 'Message']],
    body: unique.map(w => [
      w.severity === 'error' ? 'ERROR' : 'WARN',
      String(w.year),
      w.field.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase()).trim(),
      w.message,
    ]),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 14, textColor: [220, 38, 38] as [number, number, number] },
      1: { cellWidth: 14 },
      2: { cellWidth: 35 },
    },
    didParseCell(data: any) {
      if (data.column.index === 0 && data.cell.raw === 'WARN') {
        data.cell.styles.textColor = [217, 119, 6];
      }
    },
  });
}

// ── Section: Timeline ──────────────────────────────────────────────

function addTimelineSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, startY: number) {
  const pageWidth = doc.internal.pageSize.getWidth();
  let y = startY;

  const years = scenario.years;
  const cyears = computed.years;

  // Build row groups
  interface TRow { label: string; values: string[] }
  interface TGroup { title: string; rows: TRow[] }

  function val(fn: (yd: typeof years[0], cy: ComputedYear) => number | string): string[] {
    return years.map((yd, i) => {
      const v = fn(yd, cyears[i]);
      return typeof v === 'string' ? v : formatCAD(v);
    });
  }
  function pctVal(fn: (yd: typeof years[0], cy: ComputedYear) => number): string[] {
    return years.map((yd, i) => formatPct(fn(yd, cyears[i])));
  }

  const groups: TGroup[] = [
    {
      title: 'Income',
      rows: [
        { label: 'Employment', values: val((yd) => yd.employmentIncome) },
        { label: 'Self-Employment', values: val((yd) => yd.selfEmploymentIncome) },
        { label: 'Eligible Div', values: val((yd) => yd.eligibleDividends) },
        { label: 'Non-Elig Div', values: val((yd) => yd.nonEligibleDividends) },
        { label: 'Interest', values: val((yd) => yd.interestIncome) },
        { label: 'Cap Gains', values: val((yd) => yd.capitalGainsRealized) },
        { label: 'Rental Net', values: val((yd) => yd.rentalGrossIncome - yd.rentalExpenses) },
        { label: 'Pension', values: val((yd) => yd.pensionIncome) },
        { label: 'Other', values: val((yd) => yd.otherTaxableIncome) },
        { label: 'Gross Income', values: val((_yd, cy) => cy.waterfall.grossIncome) },
      ],
    },
    {
      title: 'Accounts',
      rows: [
        { label: 'RRSP Contrib', values: val((yd) => yd.rrspContribution) },
        { label: 'RRSP Withdraw', values: val((yd) => yd.rrspWithdrawal) },
        { label: 'RRSP EOY', values: val((_yd, cy) => cy.accounts.rrspEOY) },
        { label: 'TFSA Contrib', values: val((yd) => yd.tfsaContribution) },
        { label: 'TFSA Withdraw', values: val((yd) => yd.tfsaWithdrawal) },
        { label: 'TFSA EOY', values: val((_yd, cy) => cy.accounts.tfsaEOY) },
        { label: 'FHSA Contrib', values: val((yd) => yd.fhsaContribution) },
        { label: 'FHSA EOY', values: val((_yd, cy) => cy.accounts.fhsaEOY) },
        { label: 'Non-Reg Contrib', values: val((yd) => yd.nonRegContribution) },
        { label: 'Non-Reg Withdraw', values: val((yd) => yd.nonRegWithdrawal) },
        { label: 'Non-Reg EOY', values: val((_yd, cy) => cy.accounts.nonRegEOY) },
        { label: 'Savings EOY', values: val((_yd, cy) => cy.accounts.savingsEOY) },
        { label: 'LIRA/LIF EOY', values: val((_yd, cy) => cy.accounts.liraEOY) },
        { label: 'RESP EOY', values: val((_yd, cy) => cy.accounts.respEOY) },
      ],
    },
    {
      title: 'Tax Results',
      rows: [
        { label: 'Net Taxable', values: val((_yd, cy) => cy.tax.netTaxableIncome) },
        { label: 'Federal Tax', values: val((_yd, cy) => cy.tax.federalTaxPayable) },
        { label: 'Provincial Tax', values: val((_yd, cy) => cy.tax.provincialTaxPayable) },
        { label: 'CPP Total', values: val((_yd, cy) => cy.cpp.totalCPPPaid) },
        { label: 'EI Total', values: val((_yd, cy) => cy.ei.totalEI) },
        { label: 'After-Tax', values: val((_yd, cy) => cy.waterfall.afterTaxIncome) },
        { label: 'Net Cash Flow', values: val((_yd, cy) => cy.waterfall.netCashFlow) },
        { label: 'Net Worth', values: val((_yd, cy) => cy.accounts.netWorth) },
        { label: 'Marg Rate', values: pctVal((_yd, cy) => cy.tax.marginalCombinedRate) },
        { label: 'Avg All-In', values: pctVal((_yd, cy) => cy.tax.avgAllInRate) },
      ],
    },
    {
      title: 'Room & Carry-Fwd',
      rows: [
        { label: 'RRSP Room', values: val((_yd, cy) => cy.rrspUnusedRoom) },
        { label: 'TFSA Room', values: val((_yd, cy) => cy.tfsaUnusedRoom) },
        { label: 'FHSA Room', values: val((_yd, cy) => cy.fhsaUnusedRoom) },
        { label: 'Cap Loss CF', values: val((_yd, cy) => cy.capitalLossCF) },
      ],
    },
  ];

  // Build table: first column = label, rest = years
  const yearHeaders = ['Field', ...years.map(yd => String(yd.year))];

  // Flatten groups with group headers
  const body: (string[])[] = [];
  for (const g of groups) {
    // Group header row
    const headerRow = [g.title, ...years.map(() => '')];
    body.push(headerRow);
    for (const r of g.rows) {
      body.push([r.label, ...r.values]);
    }
  }

  autoTable(doc, {
    startY: y,
    margin: { left: 8, right: 8 },
    theme: 'striped',
    styles: { fontSize: 6.5, cellPadding: 1, textColor: TEXT_DARK, overflow: 'ellipsize' },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 6.5 },
    head: [yearHeaders],
    body,
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 28 },
    },
    didParseCell(data: any) {
      // Style group header rows
      if (data.section === 'body') {
        const rowData = data.row.raw as string[];
        // Check if it's a group header: all cols after first are empty
        if (rowData && data.column.index === 0 && rowData.slice(1).every((v: string) => v === '')) {
          data.cell.styles.fillColor = [226, 232, 240];
          data.cell.styles.fontStyle = 'bold';
          data.cell.styles.fontSize = 7;
        }
        // Right-align year columns
        if (data.column.index > 0) {
          data.cell.styles.halign = 'right';
        }
      }
    },
  });
}

// ── Section: Scheduling ────────────────────────────────────────────

function addSchedulingSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const items = scenario.scheduledItems ?? [];
  if (items.length === 0) {
    doc.setFontSize(8);
    doc.setTextColor(...TEXT_MED);
    doc.text('No scheduled items configured.', margin, y + 4);
    return;
  }

  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK, overflow: 'ellipsize' },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Label', 'Field', 'Type', 'Amount', 'Start', 'End', 'Growth', 'Conditions']],
    body: items.map(s => {
      const amtType = s.amountType === 'percentage' ? 'Pct' : 'Fixed';
      const amt = s.amountType === 'percentage' ? formatPct(s.amount) : formatCAD(s.amount);
      const growth = s.growthType === 'inflation' ? 'Inflation' : (s.growthRate ? formatPct(s.growthRate) : '—');
      const conds = s.conditions && s.conditions.length > 0
        ? s.conditions.map(c => `${c.field} ${c.operator} ${c.value}`).join('; ')
        : '—';
      return [
        s.label || '—',
        s.field,
        amtType,
        amt,
        String(s.startYear),
        s.endYear !== undefined ? String(s.endYear) : '∞',
        growth,
        conds,
      ];
    }),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 28 },
      7: { cellWidth: 40 },
    },
  });
  y = getY(doc) + 6;

  // Validation warnings
  const allWarnings = computed.years.flatMap(cy => cy.warnings);
  if (allWarnings.length > 0) {
    y = subTitle(doc, 'Validation Warnings', margin, y);
    const uniqueWarnings = [...new Map(allWarnings.map(w => [w.message, w])).values()];
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'plain',
      styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_MED },
      head: [['Severity', 'Field', 'Message']],
      headStyles: { fillColor: [254, 243, 199], textColor: TEXT_DARK, fontStyle: 'bold', fontSize: 7 },
      body: uniqueWarnings.slice(0, 30).map(w => [
        w.severity === 'error' ? 'ERROR' : 'WARN',
        w.field,
        w.message,
      ]),
    });
  }
}

// ── Section: Analysis ──────────────────────────────────────────────

function addAnalysisSection(doc: jsPDF, scenario: Scenario, computed: ComputedScenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const analytics = computed.analytics;

  // Tax efficiency KPIs
  y = subTitle(doc, 'Tax Efficiency', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 8, cellPadding: 2, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 8 },
    head: [['Metric', 'Value']],
    body: [
      ['Lifetime Gross Income', formatCAD(analytics.lifetimeGrossIncome)],
      ['Lifetime Total Tax (incl. CPP/EI)', formatCAD(analytics.lifetimeTotalTax + analytics.lifetimeCPPEI)],
      ['Lifetime After-Tax Income', formatCAD(analytics.lifetimeAfterTaxIncome)],
      ['Lifetime Avg Tax Rate', formatPct(analytics.lifetimeAvgTaxRate)],
      ['Lifetime Avg All-In Rate', formatPct(analytics.lifetimeAvgAllInRate)],
      ['Lifetime Cash Flow', formatCAD(analytics.lifetimeCashFlow)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 6;

  // Marginal rates by year
  y = subTitle(doc, 'Marginal Rates by Year', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7.5, cellPadding: 1.8, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7.5 },
    head: [['Year', 'Federal', 'Provincial', 'Combined', 'Avg All-In']],
    body: computed.years.map(cy => [
      String(cy.year),
      formatPct(cy.tax.marginalFederalRate),
      formatPct(cy.tax.marginalProvincialRate),
      formatPct(cy.tax.marginalCombinedRate),
      formatPct(cy.tax.avgAllInRate),
    ]),
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 16 },
      1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' }, 4: { halign: 'right' },
    },
  });
  y = getY(doc) + 6;

  // CPP/OAS deferral summary
  const ret = scenario.assumptions.retirement;
  if (ret) {
    y = subTitle(doc, 'CPP & OAS Retirement Benefits', margin, y);
    const birthYear = scenario.assumptions.birthYear ?? 0;
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'grid',
      styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
      body: [
        ['Birth Year', String(birthYear || 'Not set')],
        ['CPP Start Age', ret.cppBenefit.enabled ? String(ret.cppBenefit.startAge) : 'Disabled'],
        ['CPP Monthly Amount', ret.cppBenefit.enabled ? formatCAD(ret.cppBenefit.monthlyAmount) : '—'],
        ['OAS Start Age', ret.oasBenefit.enabled ? String(ret.oasBenefit.startAge) : 'Disabled'],
        ['OAS Monthly Amount', ret.oasBenefit.enabled ? formatCAD(ret.oasBenefit.monthlyAmount) : '—'],
        ['RRIF Conversion Age', String(ret.rrifConversionAge)],
      ],
      columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.55 }, 1: { halign: 'right' } },
    });
  }
}

// ── Section: Settings ──────────────────────────────────────────────

function addSettingsSection(doc: jsPDF, scenario: Scenario, margin: number, contentWidth: number, startY: number) {
  let y = startY;

  const a = scenario.assumptions;
  const startYear = scenario.years[0]?.year ?? a.startYear;

  // General
  y = subTitle(doc, 'General', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['Province', a.province],
      ['Start Year', String(startYear)],
      ['Number of Years', String(a.numYears)],
      ['Inflation Rate', formatPct(a.inflationRate)],
      ['CG Inclusion Rate', formatPct(a.capitalGainsInclusionRate)],
      ['CG Tiered', a.cgInclusionTiered ? 'Yes' : 'No'],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // CPP params
  y = subTitle(doc, 'CPP Parameters', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['Basic Exemption', formatCAD(a.cpp.basicExemption)],
      ['YMPE', formatCAD(a.cpp.ympe)],
      ['YAMPE', formatCAD(a.cpp.yampe)],
      ['Employee Rate (CPP1)', formatPct(a.cpp.employeeRate)],
      ['CPP2 Rate', formatPct(a.cpp.cpp2Rate)],
      ['SE Deduction Factor', formatPct(a.cpp.seDeductionFactor)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // EI params
  y = subTitle(doc, 'EI Parameters', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['Max Insurable Earnings', formatCAD(a.ei.maxInsurableEarnings)],
      ['Employee Rate', formatPct(a.ei.employeeRate)],
      ['SE Opt-In', a.ei.seOptIn ? 'Yes' : 'No'],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // Dividend params
  y = subTitle(doc, 'Dividend Parameters', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Type', 'Gross-Up', 'Federal Credit', 'Provincial Credit']],
    body: [
      ['Eligible', formatPct(a.dividendRates.eligible.grossUp), formatPct(a.dividendRates.eligible.federalCredit), formatPct(a.dividendRates.eligible.provincialCredit)],
      ['Non-Eligible', formatPct(a.dividendRates.nonEligible.grossUp), formatPct(a.dividendRates.nonEligible.federalCredit), formatPct(a.dividendRates.nonEligible.provincialCredit)],
    ],
    columnStyles: {
      0: { fontStyle: 'bold' },
      1: { halign: 'right' }, 2: { halign: 'right' }, 3: { halign: 'right' },
    },
  });
  y = getY(doc) + 4;

  // Federal brackets
  y = subTitle(doc, 'Federal Tax Brackets', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Min', 'Max', 'Rate']],
    body: a.federalBrackets.map(b => [
      formatCAD(b.min),
      b.max !== null ? formatCAD(b.max) : '∞',
      formatPct(b.rate),
    ]),
    columnStyles: { 2: { halign: 'right' } },
  });
  y = getY(doc) + 2;
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'plain',
    styles: { fontSize: 7, cellPadding: 1, textColor: TEXT_MED },
    body: [
      ['Federal BPA', formatCAD(a.federalBPA)],
      ['Employment Amount', formatCAD(a.federalEmploymentAmount)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // Provincial brackets
  y = subTitle(doc, 'Provincial Tax Brackets', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'striped',
    styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
    headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
    head: [['Min', 'Max', 'Rate']],
    body: a.provincialBrackets.map(b => [
      formatCAD(b.min),
      b.max !== null ? formatCAD(b.max) : '∞',
      formatPct(b.rate),
    ]),
    columnStyles: { 2: { halign: 'right' } },
  });
  y = getY(doc) + 2;
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'plain',
    styles: { fontSize: 7, cellPadding: 1, textColor: TEXT_MED },
    body: [
      ['Provincial BPA', formatCAD(a.provincialBPA)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // Asset returns
  y = subTitle(doc, 'Asset Returns', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['Equity', formatPct(a.assetReturns.equity)],
      ['Fixed Income', formatPct(a.assetReturns.fixedIncome)],
      ['Cash', formatPct(a.assetReturns.cash)],
      ['Savings', formatPct(a.assetReturns.savings)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // Contribution limits
  y = subTitle(doc, 'Contribution Limits', margin, y);
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['RRSP Limit', formatCAD(a.rrspLimit)],
      ['RRSP % Earned Income', formatPct(a.rrspPctEarnedIncome)],
      ['TFSA Annual Limit', formatCAD(a.tfsaAnnualLimit)],
      ['FHSA Annual Limit', formatCAD(a.fhsaAnnualLimit)],
      ['FHSA Lifetime Limit', formatCAD(a.fhsaLifetimeLimit)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 4;

  // Opening balances (new page to be safe)
  doc.addPage();
  y = subTitle(doc, 'Opening Balances', margin, 14);
  const ob = scenario.openingBalances;
  const cf = scenario.openingCarryForwards;
  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    theme: 'grid',
    styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
    body: [
      ['RRSP', formatCAD(ob.rrsp)],
      ['TFSA', formatCAD(ob.tfsa)],
      ['FHSA', formatCAD(ob.fhsa)],
      ['Non-Registered', formatCAD(ob.nonReg)],
      ['Savings', formatCAD(ob.savings)],
      ['LIRA', formatCAD(ob.lira)],
      ['RESP', formatCAD(ob.resp)],
      ['RRSP Unused Room', formatCAD(cf?.rrspUnusedRoom ?? 0)],
      ['TFSA Unused Room', formatCAD(cf?.tfsaUnusedRoom ?? 0)],
      ['Capital Loss CF', formatCAD(cf?.capitalLossCF ?? 0)],
      ['FHSA Lifetime Contribs', formatCAD(cf?.fhsaContribLifetime ?? 0)],
    ],
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
  });
  y = getY(doc) + 5;

  // Retirement config
  const ret = a.retirement;
  if (ret) {
    y = subTitle(doc, 'Retirement Configuration', margin, y);
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'grid',
      styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
      body: [
        ['Birth Year', String(a.birthYear ?? 'Not set')],
        ['CPP Enabled', ret.cppBenefit.enabled ? 'Yes' : 'No'],
        ['CPP Monthly Amount', formatCAD(ret.cppBenefit.monthlyAmount)],
        ['CPP Start Age', String(ret.cppBenefit.startAge)],
        ['OAS Enabled', ret.oasBenefit.enabled ? 'Yes' : 'No'],
        ['OAS Monthly Amount', formatCAD(ret.oasBenefit.monthlyAmount)],
        ['OAS Start Age', String(ret.oasBenefit.startAge)],
        ['RRIF Conversion Age', String(ret.rrifConversionAge)],
      ],
      columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
    });
    y = getY(doc) + 4;
  }

  // FHSA disposition
  if (a.fhsa) {
    y = subTitle(doc, 'FHSA Disposition', margin, y);
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'grid',
      styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
      body: [
        ['Disposition', a.fhsa.disposition],
        ['Disposition Year', a.fhsa.dispositionYear ? String(a.fhsa.dispositionYear) : '—'],
      ],
      columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
    });
    y = getY(doc) + 4;
  }

  // HBP
  if (a.hbp) {
    y = subTitle(doc, 'Home Buyers\' Plan', margin, y);
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'grid',
      styles: { fontSize: 7.5, cellPadding: 1.5, textColor: TEXT_DARK },
      body: [
        ['Withdrawal Year', String(a.hbp.withdrawalYear)],
        ['Withdrawal Amount', formatCAD(a.hbp.withdrawalAmount)],
        ['Repayment Start Delay', String(a.hbp.repaymentStartDelay) + ' years'],
      ],
      columnStyles: { 0: { fontStyle: 'bold', cellWidth: contentWidth * 0.45 }, 1: { halign: 'right' } },
    });
    y = getY(doc) + 4;
  }

  // Liabilities config
  const liabs = scenario.liabilities;
  if (liabs && liabs.length > 0) {
    y = subTitle(doc, 'Liabilities Configuration', margin, y);
    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      theme: 'striped',
      styles: { fontSize: 7, cellPadding: 1.5, textColor: TEXT_DARK },
      headStyles: { fillColor: HEADER_BG, textColor: WHITE, fontStyle: 'bold', fontSize: 7 },
      head: [['Label', 'Type', 'Balance', 'Rate', 'Monthly Payment', 'Investment Loan']],
      body: liabs.map(l => [
        l.label,
        l.type,
        formatCAD(l.openingBalance),
        formatPct(l.annualRate),
        formatCAD(l.monthlyPayment),
        l.isInvestmentLoan ? 'Yes' : 'No',
      ]),
      columnStyles: {
        0: { fontStyle: 'bold' },
        2: { halign: 'right' }, 3: { halign: 'right' }, 4: { halign: 'right' },
      },
    });
  }
}

// ── Main export ────────────────────────────────────────────────────

export function generatePDFReport({ scenario, computed, sections }: ReportInput) {
  const sec: PDFSections = sections ?? {
    overview: true, taxDetail: true, accounts: true, expenses: true,
    timeline: true, scheduling: true, analysis: true, warnings: true, settings: true,
  };

  const doc = new jsPDF('portrait', 'mm', 'letter');
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 14;
  const contentWidth = pageWidth - margin * 2;

  // Header on first page
  const headerY = addHeader(doc, scenario, margin);
  (doc as any)._headerY = headerY;

  // Track whether we've used the initial page yet.
  // The first section reuses page 1 (which has the header); subsequent sections add new pages.
  let isFirstSection = true;

  // Generic wrapper: if this is the first section, use the header page; otherwise add a new portrait page + section title.
  function startSection(title: string): number {
    if (isFirstSection) {
      isFirstSection = false;
      // First section renders right below the header
      return (doc as any)._headerY ?? 32;
    }
    doc.addPage();
    return sectionTitle(doc, title, margin);
  }

  // Section functions that use startSection
  const sectionOrder: { key: keyof PDFSections; fn: () => void }[] = [
    { key: 'overview', fn: () => addOverviewSection(doc, scenario, computed, margin, contentWidth, startSection('Overview')) },
    { key: 'taxDetail', fn: () => addTaxDetailSection(doc, scenario, computed, margin, contentWidth, startSection('Tax Detail')) },
    { key: 'accounts', fn: () => addAccountsSection(doc, scenario, computed, margin, contentWidth, startSection('Accounts')) },
    { key: 'expenses', fn: () => addExpensesSection(doc, scenario, computed, margin, contentWidth, startSection('Expenses')) },
    { key: 'timeline', fn: () => {
      // Timeline needs landscape. If it's the first section, the header page is portrait — add landscape after it.
      // If not first, startSection already added a portrait page we need to replace.
      if (isFirstSection) {
        isFirstSection = false;
        // Header is on page 1 (portrait). Add landscape page for timeline.
        doc.addPage('l');
        addTimelineSection(doc, scenario, computed, margin, sectionTitle(doc, 'Timeline — All Fields by Year', margin));
      } else {
        // Add a landscape page directly (don't use startSection which adds portrait)
        doc.addPage('l');
        addTimelineSection(doc, scenario, computed, margin, sectionTitle(doc, 'Timeline — All Fields by Year', margin));
      }
    }},
    { key: 'scheduling', fn: () => addSchedulingSection(doc, scenario, computed, margin, contentWidth, startSection('Scheduling')) },
    { key: 'analysis', fn: () => addAnalysisSection(doc, scenario, computed, margin, contentWidth, startSection('Analysis')) },
    { key: 'warnings', fn: () => addWarningsSection(doc, scenario, computed, margin, contentWidth, startSection('Validation Warnings')) },
    { key: 'settings', fn: () => addSettingsSection(doc, scenario, margin, contentWidth, startSection('Settings & Assumptions')) },
  ];

  for (const s of sectionOrder) {
    if (sec[s.key]) s.fn();
  }

  if (isFirstSection) {
    // No sections selected — nothing to generate
    return;
  }

  addFooter(doc, margin);

  const filename = `${scenario.name.replace(/[^a-zA-Z0-9]/g, '_')}_Report.pdf`;
  doc.save(filename);
}
